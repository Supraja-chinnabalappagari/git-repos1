# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-d9su6iPG6NqPtNU1rydkoERIPVMExKS
"""

pip install opencv-python opencv-python-headless torch torchvision

# Commented out IPython magic to ensure Python compatibility.
!git clone https://github.com/ultralytics/yolov5
# %cd yolov5
!pip install -r requirements.txt

import cv2
import torch
from IPython.display import display, Image
from yolov5.models.experimental import attempt_load
from yolov5.utils.general import non_max_suppression
from yolov5.utils.torch_utils import select_device

# Load YOLOv5 model
model_path = 'yolov5s.pt'  # Path to the model
device = select_device('cuda' if torch.cuda.is_available() else 'cpu')
model = attempt_load(model_path)
model.eval()

img_size = 640  # Image size

# Paths to video files
media_files = ['/content/dhaka_traffic.mp4', '/content/road_trafifc.mp4', '/content/traffic_video.avi']  # Replace with your video files

def process_frame(frame):
    h, w = frame.shape[:2]
    scale_factor_w = w / img_size
    scale_factor_h = h / img_size

    # Prepare the frame for detection
    img = cv2.resize(frame, (img_size, img_size))
    img = img[:, :, ::-1].transpose(2, 0, 1).copy()  # BGR to RGB, to 3x416x416, make a copy to avoid negative strides
    img = torch.from_numpy(img).float().div(255.0).unsqueeze(0).to(device)

    # Inference
    with torch.no_grad():
        pred = model(img)[0]
    pred = non_max_suppression(pred, 0.4, 0.5)

    vehicle_count = 0

    # Process detections
    for det in pred:  # detections per image
        if det is not None and len(det):
            for *xyxy, conf, cls in det:
                xyxy[0] *= scale_factor_w
                xyxy[1] *= scale_factor_h
                xyxy[2] *= scale_factor_w
                xyxy[3] *= scale_factor_h
                label = f'{model.names[int(cls)]} {conf:.2f}'
                # Draw bounding box
                cv2.rectangle(frame, (int(xyxy[0]), int(xyxy[1])), (int(xyxy[2]), int(xyxy[3])), (255, 0, 0), 2)
                cv2.putText(frame, label, (int(xyxy[0]), int(xyxy[1]) - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 2)
                vehicle_count += 1
    return frame, vehicle_count

def analyze_traffic(media_files):
    vehicle_counts = {}
    for media in media_files:
        cap = cv2.VideoCapture(media)
        if not cap.isOpened():
            print(f"Error opening video file: {media}")
            continue
        total_count = 0
        frame_count = 0
        while cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                break
            frame, count = process_frame(frame)
            total_count += count
            frame_count += 1
            if frame_count % 100 == 0:  # Save and display every 100th frame
                frame_path = f'/content/frame_{frame_count}.jpg'
                cv2.imwrite(frame_path, frame)
                display(Image(filename=frame_path))
                print(f"Processed {frame_count} frames from {media}")
        cap.release()
        avg_count = total_count / frame_count if frame_count else 0
        vehicle_counts[media] = avg_count
    return vehicle_counts

def suggest_speed_limit(vehicle_count):
    if vehicle_count < 10:
        return "60 km/h"
    elif vehicle_count < 30:
        return "40 km/h"
    else:
        return "20 km/h"

def suggest_traffic_direction(vehicle_count):
    if vehicle_count > 30:
        return "Move to the left lane"
    else:
        return "Stay on the current lane"

def main():
    vehicle_counts = analyze_traffic(media_files)
    if not vehicle_counts:
        print("No valid video files processed.")
        return
    min_traffic_area = min(vehicle_counts, key=vehicle_counts.get)
    max_traffic_area = max(vehicle_counts, key=vehicle_counts.get)

    print(f"Traffic Analysis Results:")
    print(f"-------------------------")
    print(f"Area with least traffic: {min_traffic_area}")
    print(f"   - Vehicle count: {vehicle_counts[min_traffic_area]}")
    print(f"   - Suggested speed limit: {suggest_speed_limit(vehicle_counts[min_traffic_area])}")

    print(f"\nDetailed Analysis:")
    for area, count in vehicle_counts.items():
        print(f"{area}: {count} vehicles, Suggestion: {suggest_traffic_direction(count)}")

if __name__ == "__main__":
    main()